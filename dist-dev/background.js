var N=Object.defineProperty;var f=(n,o,e)=>o in n?N(n,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[o]=e;var l=(n,o,e)=>f(n,typeof o!="symbol"?o+"":o,e);class y{constructor(o,e,t=1){l(this,"dbName");l(this,"storeName");l(this,"version");l(this,"db");this.dbName=o,this.storeName=e,this.version=t,this.db=null}async init(){return new Promise((o,e)=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=r=>{const a=r.target,s=a.result;if(!s.objectStoreNames.contains(this.storeName))s.createObjectStore(this.storeName,{keyPath:"id"}).createIndex("domainIndex","domain",{unique:!1}),console.log("Object store and domainIndex created");else{const i=a.transaction.objectStore(this.storeName);i.indexNames.contains("domainIndex")||(i.createIndex("domainIndex","domain",{unique:!1}),console.log("domainIndex added to existing object store"));const u=i.openCursor();u.onsuccess=b=>{const c=b.target.result;if(c){const h=c.value;h.domain||(h.domain=new URL(h.url).hostname,c.update(h)),c.continue()}}}},t.onsuccess=r=>{this.db=r.target.result,o("success")},t.onerror=r=>{e(`IndexedDB error: ${r.target.error}`)}})}async add(o){return new Promise((e,t)=>{if(!this.db)return t("Database is not initialized");const s=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).add(o);s.onsuccess=()=>e(s.result),s.onerror=()=>t(`Add failed: ${s.error}`)})}async put(o){return new Promise((e,t)=>{if(!this.db)return t("Database is not initialized");const s=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).put(o);s.onsuccess=()=>e(s.result),s.onerror=()=>t(`Put failed: ${s.error}`)})}async get(o){return new Promise((e,t)=>{if(!this.db)return t("Database is not initialized");const s=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).get(o);s.onsuccess=()=>e(s.result),s.onerror=()=>t(`Get failed: ${s.error}`)})}async getAll(){return new Promise((o,e)=>{if(!this.db)return e("Database is not initialized");const a=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).getAll();a.onsuccess=()=>o(a.result),a.onerror=()=>e(`GetAll failed: ${a.error}`)})}async delete(o){return new Promise((e,t)=>{if(!this.db)return t("Database is not initialized");const s=this.db.transaction(this.storeName,"readwrite").objectStore(this.storeName).delete(o);s.onsuccess=()=>e(!0),s.onerror=()=>t(`Delete failed: ${s.error}`)})}async getByDomain(o){return new Promise((e,t)=>{if(!this.db)return t("Database is not initialized");const s=this.db.transaction(this.storeName,"readonly").objectStore(this.storeName).index("domainIndex"),d=IDBKeyRange.only(o),i=[],u=s.openCursor(d);u.onsuccess=b=>{const c=b.target.result;c?(i.push(c.value),c.continue()):e(i)},u.onerror=()=>t(`Failed to get by domain: ${u.error}`)})}}const m=new y("SiteNoteDB","notes",3);m.init().catch(n=>console.error("Failed to initialize DB:",n));chrome.runtime.onMessage.addListener((n,o,e)=>{if(n.type==="GET_CURRENT_TAB")return chrome.tabs.query({active:!0,currentWindow:!0},t=>{const r=t[0];e({tab:r})}),!0;if(n.type==="SAVE_NOTE"){const{id:t,url:r,data:a,title:s}=n.payload,d=new URL(r);return m.put({id:t,url:r,data:a,domain:d.hostname,created_at:new Date,title:s}).then(()=>{e({success:!0})}).catch(i=>{console.error("Failed to save note:",i),e({success:!1,error:i})}),!0}if(n.type==="GET_NOTE"){const{id:t}=n.payload;return m.get(t).then(r=>{e({success:!0,data:r==null?void 0:r.data})}).catch(r=>{console.error("Failed to get note:",r),e({success:!1,error:r})}),!0}if(chrome.runtime.onInstalled.addListener(()=>{chrome.scripting.registerContentScripts([{id:"session-script",js:["content.js"],css:["tailwind.css"],persistAcrossSessions:!1,matches:["<all_urls>"],runAt:"document_idle"}]).then(()=>{}).catch(t=>console.error("Error registering content script",t))}),n.type==="GET_DOMAIN_NOTES"){const{domain:t}=n.payload;return m.getByDomain(t).then(r=>{console.log("=>(background.ts:50) notes",r),e(r)}).catch(r=>{console.error("Failed to fetch notes by domain:",r)}),!0}});
